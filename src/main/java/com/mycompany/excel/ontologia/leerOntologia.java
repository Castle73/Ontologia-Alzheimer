/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.mycompany.excel.ontologia;

import com.hp.hpl.jena.ontology.OntClass;
import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.ontology.OntModelSpec;
import com.hp.hpl.jena.ontology.OntResource;
import com.hp.hpl.jena.rdf.model.ModelFactory;
import com.hp.hpl.jena.util.FileManager;
import com.hp.hpl.jena.util.iterator.ExtendedIterator;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import org.apache.poi.hssf.util.CellReference;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellType;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.mindswap.pellet.jena.PelletReasonerFactory;

/**
 *
 * @author pc
 */
public class leerOntologia extends javax.swing.JFrame {

    /**
     * variables
     */
    private OntModel ontologyModelActual; //this is the main of Ontology model
    private OntModel ontologyModelNuevo; //this is the main of Ontology model
    private FileInputStream fileExcel;
    private FileInputStream fileOwl;
    private TreeNode rootDisplay;
    private DefaultMutableTreeNode root;
    private Map<String, String> ns;
    private Map<String, String> est;

    /**
     * Creates new form leerOntologia
     */
    public leerOntologia() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTarbolOntOriginal = new javax.swing.JTree();
        jBcOn = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTarbolOntNuevo = new javax.swing.JTree();
        jBdOn = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jBeTo = new javax.swing.JButton();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTeSt = new javax.swing.JTree();
        jBcEx = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTarbolOntOriginal.setModel(null);
        jScrollPane1.setViewportView(jTarbolOntOriginal);

        jBcOn.setText("cargar ontologia");
        jBcOn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBcOnActionPerformed(evt);
            }
        });

        jTarbolOntNuevo.setModel(null);
        jScrollPane3.setViewportView(jTarbolOntNuevo);

        jBdOn.setText("descargar OWL");
        jBdOn.setEnabled(false);
        jBdOn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBdOnActionPerformed(evt);
            }
        });

        jLabel1.setText("ontologia actual");

        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel2.setText("ontologia nueva");

        jLabel3.setText("migracion de datos de excel a la ontologia");

        jBeTo.setText("pasar datos de excel -> ontologia");
        jBeTo.setEnabled(false);
        jBeTo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBeToActionPerformed(evt);
            }
        });

        jTeSt.setModel(null);
        jScrollPane4.setViewportView(jTeSt);

        jBcEx.setText("cargar excel");
        jBcEx.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jBcExActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addComponent(jScrollPane4)
                    .addComponent(jLabel3, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jBeTo, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(186, 186, 186))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 249, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(37, 37, 37)
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 249, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(75, 75, 75)
                        .addComponent(jLabel1)))
                .addContainerGap(32, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 107, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(63, 63, 63)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jBcOn)
                            .addComponent(jBcEx, javax.swing.GroupLayout.PREFERRED_SIZE, 111, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jBdOn)))
                .addGap(112, 112, 112))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(16, 16, 16)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jBeTo)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane4, javax.swing.GroupLayout.PREFERRED_SIZE, 121, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(3, 3, 3)
                .addComponent(jBcEx)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jBcOn)
                    .addComponent(jBdOn))
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 448, Short.MAX_VALUE)
                    .addComponent(jScrollPane1))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jBcOnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBcOnActionPerformed
        jBcEx.setEnabled(false);
        jBcOn.setEnabled(false);
        jBdOn.setEnabled(false);
        jBeTo.setEnabled(false);
        // muestra el cuadro de diálogo de archivos, para que el usuario pueda elegir el archivo a abrir
        JFileChooser selectorArchivos = new JFileChooser();
        selectorArchivos.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);

        //indicamos la descripción del tipo de archivo que abriremos y la extensión del mismo.
        FileNameExtensionFilter filtro = new FileNameExtensionFilter("Archivos OWL", "OWL");
        selectorArchivos.setFileFilter(filtro);
        //directorio default
        selectorArchivos.setCurrentDirectory(new File(System.getProperty("user.dir")));

        // indica cual fue la accion de usuario sobre el jfilechooser
        int resultado = selectorArchivos.showOpenDialog(this);

        if (resultado != 1) {
            File archivo = selectorArchivos.getSelectedFile(); // obtiene el archivo seleccionado
            if ((archivo == null) || (archivo.getName().equals(""))) {
                JOptionPane.showMessageDialog(this, "Nombre de archivo inválido", "Nombre de archivo inválido", JOptionPane.ERROR_MESSAGE);
            } else {
                String rutaArchivo = selectorArchivos.getSelectedFile().getAbsolutePath();
                try {
                    fileOwl = new FileInputStream(new File(rutaArchivo));
                    createOntologyModelFromFile(rutaArchivo);
                    crearArbolOntologiaActual();
                    JOptionPane.showMessageDialog(this, "ontologia cargada", "Carga archivo", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                }
            }
        } else {
            JOptionPane.showMessageDialog(this, "accion cancelada");
        }
        if (fileExcel != null && fileOwl != null) {
            jBeTo.setEnabled(true);
        }
        jBcEx.setEnabled(true);
        jBcOn.setEnabled(true);
    }//GEN-LAST:event_jBcOnActionPerformed

    private void jBcExActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBcExActionPerformed
        jBcEx.setEnabled(false);
        jBcOn.setEnabled(false);
        jBdOn.setEnabled(false);
        jBeTo.setEnabled(false);
        // muestra el cuadro de diálogo de archivos, para que el usuario pueda elegir el archivo a abrir
        JFileChooser selectorArchivos = new JFileChooser();
        selectorArchivos.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);

        //indicamos la descripción del tipo de archivo que abriremos y la extensión del mismo.
        FileNameExtensionFilter filtro = new FileNameExtensionFilter("Archivos Excel(xls,xlsx)", "xls", "xlsx");
        selectorArchivos.setFileFilter(filtro);
        //directorio default
        selectorArchivos.setCurrentDirectory(new File(System.getProperty("user.dir")));

        // indica cual fue la accion de usuario sobre el jfilechooser
        int resultado = selectorArchivos.showOpenDialog(this);

        if (resultado != 1) {
            File archivo = selectorArchivos.getSelectedFile(); // obtiene el archivo seleccionado
            if ((archivo == null) || (archivo.getName().equals(""))) {
                JOptionPane.showMessageDialog(this, "Nombre de archivo inválido", "Nombre de archivo inválido", JOptionPane.ERROR_MESSAGE);
            } else {
                String rutaArchivo = selectorArchivos.getSelectedFile().getAbsolutePath();
                try {
                    fileExcel = new FileInputStream(new File(rutaArchivo));
                    JOptionPane.showMessageDialog(this, "Excel cargado", "Carga archivo", JOptionPane.INFORMATION_MESSAGE);
                } catch (Exception e) {
                    System.out.println(e.getMessage());
                }
            }
        } else {
            JOptionPane.showMessageDialog(this, "accion cancelada");
        }
        if (fileExcel != null && fileOwl != null) {
            jBeTo.setEnabled(true);
        }
        jBcEx.setEnabled(true);
        jBcOn.setEnabled(true);
    }//GEN-LAST:event_jBcExActionPerformed

    private void jBeToActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBeToActionPerformed
        jBeTo.setEnabled(false);
        jBdOn.setEnabled(false);
        jBcEx.setEnabled(false);
        jBcOn.setEnabled(false);
        arbolEstados(root);
        DefaultTreeModel defaultTreeModel = new DefaultTreeModel(rootDisplay);
        jTeSt.setModel(defaultTreeModel);
        obtenerEstados(ontologyModelActual.listHierarchyRootClasses().toList());
        recorrerExcel(new UbicacionHoja(4, 1), new UbicacionHoja(7, 3));
        crearArbolOntologiaNuevo();
        jBdOn.setEnabled(true);
        jBeTo.setEnabled(false);
        jBcEx.setEnabled(true);
        jBcOn.setEnabled(true);
    }//GEN-LAST:event_jBeToActionPerformed

    private void jBdOnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jBdOnActionPerformed
        jBeTo.setEnabled(false);
        jBdOn.setEnabled(false);
        jBcEx.setEnabled(false);
        jBcOn.setEnabled(false);
        // muestra el cuadro de diálogo de archivos, para que el usuario pueda elegir el archivo a guardar
        JFileChooser saveArchivos = new JFileChooser();
        saveArchivos.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);
        saveArchivos.setDialogType(JFileChooser.SAVE_DIALOG);

        //indicamos la descripción del tipo de archivo que abriremos y la extensión del mismo.
        FileNameExtensionFilter filtro = new FileNameExtensionFilter("Archivos OWL", "OWL");
        saveArchivos.setFileFilter(filtro);
        //directorio default
        saveArchivos.setCurrentDirectory(new File(System.getProperty("user.dir")));

        int retrival = saveArchivos.showSaveDialog(this);
        if (retrival == JFileChooser.APPROVE_OPTION) {
            FileWriter out = null;
            try {
                // XML format - long and verbose
                String fl;
                if(!saveArchivos.getSelectedFile().exists()){
                    fl=saveArchivos.getSelectedFile() + ".owl";
                out = new FileWriter(fl);
                }else{
                    fl= saveArchivos.getSelectedFile().getAbsolutePath();
                    out = new FileWriter(fl);
                }
                ontologyModelNuevo.write(out, "RDF/XML-ABBREV");
                JOptionPane.showMessageDialog(this, "archivo guardado en: "+fl, "Archivo guardado",JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            } finally {
                if (out != null) {
                    try {
                        out.close();
                    } catch (IOException ex) {
                        System.out.println(ex.getMessage());
                        ex.printStackTrace();
                    }
                }
            }

        }
        jBeTo.setEnabled(false);
        if (ontologyModelNuevo != null) {
            jBdOn.setEnabled(true);
        } else {
            jBdOn.setEnabled(false);
        }
        jBcEx.setEnabled(true);
        jBcOn.setEnabled(true);
    }//GEN-LAST:event_jBdOnActionPerformed

    /**
     * crea un arbol con la ontoligia nueva graficamente
     */
    private void crearArbolOntologiaNuevo() {
        List<OntClass> ontologyModelActualLoc = ontologyModelNuevo.listHierarchyRootClasses().toList();
        if (ontologyModelActualLoc.size() > 0) {
            DefaultMutableTreeNode root = new DefaultMutableTreeNode("root");
            crearArbolRecursivoNuevo(root, ontologyModelActualLoc);
            DefaultTreeModel defaultTreeModel = new DefaultTreeModel(root);
            jTarbolOntNuevo.setModel(defaultTreeModel);
        }
    }

    /**
     * llena la variable DefaultMutableTreeNode
     *
     * @param node es el DefaultMutableTreeNode raiz
     * @param classOnto en la OntClass raiz
     */
    public void crearArbolRecursivoNuevo(DefaultMutableTreeNode node, List<OntClass> classOnto) {
        DefaultMutableTreeNode nuevoElem = null;
        DefaultMutableTreeNode nuevoElemInt = null;
        for (OntClass val : classOnto) {
            if (!val.isComplementClass() && !val.isAnon()) {
                /*
                *if (val.getLocalName().equalsIgnoreCase("deprimido")) {
                *    System.out.println("com.mycompany.excel.ontologia.leerOntologia.crearArbolRecursivoNuevo()");
                *}
                 */
                nuevoElem = new DefaultMutableTreeNode(val.getLocalName());
                node.add(nuevoElem);
                ExtendedIterator<? extends OntResource> listIntI = val.listInstances(true);
                if (listIntI != null) {
                    List<? extends OntResource> listIntF = listIntI.toList();
                    for (OntResource next : listIntF) {
                        String dt = next.getURI();
                        String[] nameInd = dt.split("#", 2);
                        nuevoElemInt = new DefaultMutableTreeNode(nameInd[1]);
                        nuevoElem.add(nuevoElemInt);
                    }
                }

            }
            //imprimimos el objeto pivote
            if (val.listSubClasses().toList().size() > 0) {
                crearArbolRecursivoNuevo(nuevoElem, val.listSubClasses().toList());
            }
        }
    }

    /**
     * recorre el excel, recoge los datos y crea una nueva ontologia con los
     * datos ingresados
     *
     * @param VideoNombreObj posicion inicia del nombre del video
     * @param datoTiempoObj posicion inicia de los datos del video
     */
    void recorrerExcel(UbicacionHoja VideoNombreObj, UbicacionHoja datoTiempoObj) {
        String stVideo = "";
        String stTiempo = "";
        String stEstado = "";
        int filasLimite = 0;
        int columnasLimite = 0;
        int numVideos = 0;
        int saltos = 8;
        // leer archivo excel
        XSSFWorkbook worbook;
        try {
            // leer archivo excel
            worbook = new XSSFWorkbook(fileExcel);
            //obtener la hoja que se va leer
            XSSFSheet sheet = worbook.getSheetAt(0);
            filasLimite = sheet.getLastRowNum();
            columnasLimite = sheet.getRow(
                    (new CellReference(VideoNombreObj.getF2(), VideoNombreObj.getC2()))
                            .getRow())
                    .getLastCellNum();
            numVideos = filasLimite / saltos;
            salirTest:
            for (int i = 0; i < numVideos; i++) {
                // Obtiene la referencia de la celda que debe seleccionar
                CellReference ref = new CellReference(VideoNombreObj.getF2(), VideoNombreObj.getC2());
                // Obtiene la fila dependiendo la celda que se configura en el archivo config.properties
                Row fila = sheet.getRow(ref.getRow());
                if (fila != null) {
                    // Obtiene la columna dependiendo la celda que se configura en el archivo config.properties
                    Cell columna = fila.getCell(ref.getCol());
                    if (columna != null && columna.getCellType() != CellType.BLANK) {
                        // Obtiene la informacion que tiene la celda pero no puede ser el resultado de una formula
                        stVideo = "";
                        if (columna.getCellType() == CellType.STRING) {
                            stVideo = columna.getStringCellValue();
                        } else if (columna.getCellType() == CellType.NUMERIC) {
                            stVideo = String.valueOf(columna.getNumericCellValue());
                        }
                        //System.out.println("La informacion es: " + datoExcel);
                        /*
                        *System.out.println("maximo filas: " + filasLimite);
                        *System.out.println("maximo columnas: " + columnasLimite);
                        *System.out.println("numero videos: " + numVideos);
                         */

                        //parte 1
                        for (int j = datoTiempoObj.getC2(); j < columnasLimite; j++) {
                            // Obtiene la referencia de la celda que debe seleccionar
                            CellReference ref2 = new CellReference(datoTiempoObj.getF2(), j);
                            // Obtiene la fila dependiendo la celda que se configura en el archivo config.properties
                            Row fila2 = sheet.getRow(ref2.getRow());
                            if (fila2 != null) {
                                // Obtiene la columna dependiendo la celda que se configura en el archivo config.properties
                                Cell columna2 = fila2.getCell(ref2.getCol());
                                if (columna2 != null && columna2.getCellType() != CellType.BLANK) {
                                    if (columna2.getCellType() == CellType.STRING) {
                                        stTiempo = columna2.getStringCellValue();
                                    } else if (columna2.getCellType() == CellType.NUMERIC) {
                                        stTiempo = String.valueOf(columna2.getNumericCellValue());
                                    }
                                }
                            }

                            // parte 2
                            // Obtiene la referencia de la celda que debe seleccionar
                            CellReference ref3 = new CellReference(datoTiempoObj.getF2() + 2, j);
                            // Obtiene la fila dependiendo la celda que se configura en el archivo config.properties
                            Row fila3 = sheet.getRow(ref3.getRow());
                            if (fila3 != null) {
                                // Obtiene la columna dependiendo la celda que se configura en el archivo config.properties
                                Cell columna3 = fila3.getCell(ref3.getCol());
                                if (columna3 != null && columna3.getCellType() != CellType.BLANK) {
                                    if (columna3.getCellType() == CellType.STRING) {
                                        stEstado = columna3.getStringCellValue();
                                    } else if (columna3.getCellType() == CellType.NUMERIC) {
                                        stEstado = String.valueOf(columna3.getNumericCellValue());
                                    }
                                    if (!stTiempo.isEmpty() && !stEstado.isEmpty()) {
                                        //System.out.println("La informacion 2.1 es: " + datoExcel1);
                                        //System.out.println("La informacion 2.2 es: " + datoExcel2);
                                        ontologyModelNuevo = ontologyModelActual;
                                        for (Map.Entry<String, String> entry : est.entrySet()) {
                                            String key = entry.getKey();
                                            String val = entry.getValue();
                                            if (stEstado.equalsIgnoreCase(key)) {
                                                String nombreIndividuo = ns.get("") + stVideo + "||" + stTiempo + "||" + stEstado;
                                                ontologyModelNuevo.createIndividual(nombreIndividuo,
                                                        ontologyModelNuevo.getResource(val));
                                                //break salirTest;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        datoTiempoObj.setF2(datoTiempoObj.getF2() + saltos);
                    }
                }
                VideoNombreObj.setF2(VideoNombreObj.getF2() + saltos);
            }
            /*
            //---------------------
            *
            *FileWriter out = null;
            *try {
            *    // XML format - long and verbose
            *
            *    out = new FileWriter(System.getProperty("user.dir") + "\\" + "mymodel.owl");
            *    ontologyModelNuevo.write(out, "RDF/XML-ABBREV");
            *} finally {
            *    if (out != null) {
            *        try {
            *            out.close();
            *        } catch (IOException ignore) {
            *        }
            *    }
            *}
            //---------------------
             */
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
        }
    }

    /**
     * caraga el DefaultMutableTreeNode raiz solo de los estados
     *
     * @param node DefaultMutableTreeNode raiz
     */
    private void arbolEstados(DefaultMutableTreeNode node) {
        salir:
        if (node.getChildCount() > 0) {
            int num = node.getChildCount();
            for (int i = 0; i < num; i++) {
                if (node.getChildAt(i).toString().equals("Estado")) {
                    rootDisplay = node.getChildAt(i);
                    break salir;
                }
                arbolEstados((DefaultMutableTreeNode) node.getChildAt(i));
            }
        }
    }

    /**
     * obtenemos los estados de la clase Estado
     *
     * @param classOnto en la OntClass raiz
     */
    public void obtenerEstados(List<OntClass> classOnto) {
        est = new LinkedHashMap<String, String>();
        salir:
        for (OntClass val : classOnto) {
            if (!val.isComplementClass() && !val.isAnon() && val.getLocalName().equals("Estado")) {
                if (val.listSubClasses().toList().size() > 0) {
                    for (OntClass ontClass : val.listSubClasses().toList()) {
                        if (!ontClass.isComplementClass() && !ontClass.isAnon()) {
                            est.put(ontClass.getLocalName(), ontClass.getURI());
                            //System.out.println("estado: "+ontClass.getLocalName()+" - "+"valor: "+est.get(ontClass.getLocalName()));
                        }
                    }
                }
                break salir;
            }
            //imprimimos el objeto pivote
            if (val.listSubClasses().toList().size() > 0) {
                obtenerEstados(val.listSubClasses().toList());
            }
        }
    }

    /**
     * crea un arbol con la ontoligia actual graficamente
     */
    private void crearArbolOntologiaActual() {
        List<OntClass> ontologyModelActualLoc = ontologyModelActual.listHierarchyRootClasses().toList();
        if (ontologyModelActualLoc.size() > 0) {
            root = new DefaultMutableTreeNode("root");
            crearArbolRecursivo(root, ontologyModelActualLoc);
            DefaultTreeModel defaultTreeModel = new DefaultTreeModel(root);
            jTarbolOntOriginal.setModel(defaultTreeModel);
        }
    }

    /**
     * llena la variable DefaultMutableTreeNode
     *
     * @param node es el DefaultMutableTreeNode raiz
     * @param classOnto en la OntClass raiz
     */
    public void crearArbolRecursivo(DefaultMutableTreeNode node, List<OntClass> classOnto) {
        DefaultMutableTreeNode nuevoElem = null;
        for (OntClass val : classOnto) {
            if (!val.isComplementClass() && !val.isAnon()) {
                nuevoElem = new DefaultMutableTreeNode(val.getLocalName());
                node.add(nuevoElem);
            }
            //imprimimos el objeto pivote
            if (val.listSubClasses().toList().size() > 0) {
                crearArbolRecursivo(nuevoElem, val.listSubClasses().toList());
            }
        }
    }

    /**
     * crea el archivo OWL a partir del archivo leido
     *
     * @param owlFile
     */
    public void createOntologyModelFromFile(String owlFile) {
        InputStream in;
        in = FileManager.get().open(owlFile);
        //OntModel model1 = ModelFactory.createOntologyModel(PelletReasonerFactory.THE_SPEC);
        OntModel model1 = ModelFactory.createOntologyModel(OntModelSpec.OWL_MEM);
        model1.read(in, "", "RDF/XML");
        ontologyModelActual = model1;
        ns = model1.getNsPrefixMap();
    }

    /**
     * resetea variables
     */
    public void resetOntology() {
        ontologyModelActual = null;
        jTarbolOntOriginal.setModel(null);
        jTarbolOntNuevo.setModel(null);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(leerOntologia.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(leerOntologia.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(leerOntologia.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(leerOntologia.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new leerOntologia().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jBcEx;
    private javax.swing.JButton jBcOn;
    private javax.swing.JButton jBdOn;
    private javax.swing.JButton jBeTo;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JScrollPane jScrollPane4;
    private javax.swing.JTree jTarbolOntNuevo;
    private javax.swing.JTree jTarbolOntOriginal;
    private javax.swing.JTree jTeSt;
    // End of variables declaration//GEN-END:variables
}
